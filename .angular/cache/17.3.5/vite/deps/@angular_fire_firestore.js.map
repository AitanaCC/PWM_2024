{
  "version": 3,
  "sources": ["../../../../../node_modules/rxfire/firestore/index.esm.js", "../../../../../node_modules/@angular/fire/fesm2022/angular-fire-firestore.mjs"],
  "sourcesContent": ["import { onSnapshot, refEqual, getCountFromServer } from 'firebase/firestore';\r\nimport { Observable, from, pipe } from 'rxjs';\r\nimport { map, scan, distinctUntilChanged, filter, startWith, pairwise } from 'rxjs/operators';\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\r\nfunction fromRef(ref, options) {\r\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\r\n    /* eslint-enable @typescript-eslint/no-explicit-any */\r\n    return new Observable(function (subscriber) {\r\n        var unsubscribe = onSnapshot(ref, options, {\r\n            next: subscriber.next.bind(subscriber),\r\n            error: subscriber.error.bind(subscriber),\r\n            complete: subscriber.complete.bind(subscriber),\r\n        });\r\n        return { unsubscribe: unsubscribe };\r\n    });\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction doc(ref) {\r\n    return fromRef(ref, { includeMetadataChanges: true });\r\n}\r\n/**\r\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\r\n * @param query\r\n * @param options\r\n */\r\nfunction docData(ref, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, options); }));\r\n}\r\nfunction snapToData(snapshot, options) {\r\n    var _a;\r\n    if (options === void 0) { options = {}; }\r\n    var data = snapshot.data(options);\r\n    // match the behavior of the JS SDK when the snapshot doesn't exist\r\n    // it's possible with data converters too that the user didn't return an object\r\n    if (!snapshot.exists() || typeof data !== 'object' || data === null || !options.idField) {\r\n        return data;\r\n    }\r\n    return __assign(__assign({}, data), (_a = {}, _a[options.idField] = snapshot.id, _a));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\r\n/**\r\n * Create an operator that determines if a the stream of document changes\r\n * are specified by the event filter. If the document change type is not\r\n * in specified events array, it will not be emitted.\r\n */\r\nvar filterEvents = function (events) {\r\n    return filter(function (changes) {\r\n        var hasChange = false;\r\n        for (var i = 0; i < changes.length; i++) {\r\n            var change = changes[i];\r\n            if (events && events.indexOf(change.type) >= 0) {\r\n                hasChange = true;\r\n                break;\r\n            }\r\n        }\r\n        return hasChange;\r\n    });\r\n};\r\n/**\r\n * Splice arguments on top of a sliced array, to break top-level ===\r\n * this is useful for change-detection\r\n */\r\nfunction sliceAndSplice(original, start, deleteCount) {\r\n    var args = [];\r\n    for (var _i = 3; _i < arguments.length; _i++) {\r\n        args[_i - 3] = arguments[_i];\r\n    }\r\n    var returnArray = original.slice();\r\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args, false));\r\n    return returnArray;\r\n}\r\n/**\r\n * Creates a new sorted array from a new change.\r\n * @param combined\r\n * @param change\r\n */\r\nfunction processIndividualChange(combined, change) {\r\n    switch (change.type) {\r\n        case 'added':\r\n            if (combined[change.newIndex] &&\r\n                refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;\r\n            else {\r\n                return sliceAndSplice(combined, change.newIndex, 0, change);\r\n            }\r\n            break;\r\n        case 'modified':\r\n            if (combined[change.oldIndex] == null ||\r\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\r\n                // When an item changes position we first remove it\r\n                // and then add it's new position\r\n                if (change.oldIndex !== change.newIndex) {\r\n                    var copiedArray = combined.slice();\r\n                    copiedArray.splice(change.oldIndex, 1);\r\n                    copiedArray.splice(change.newIndex, 0, change);\r\n                    return copiedArray;\r\n                }\r\n                else {\r\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\r\n                }\r\n            }\r\n            break;\r\n        case 'removed':\r\n            if (combined[change.oldIndex] &&\r\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\r\n                return sliceAndSplice(combined, change.oldIndex, 1);\r\n            }\r\n            break;\r\n    }\r\n    return combined;\r\n}\r\n/**\r\n * Combines the total result set from the current set of changes from an incoming set\r\n * of changes.\r\n * @param current\r\n * @param changes\r\n * @param events\r\n */\r\nfunction processDocumentChanges(current, changes, events) {\r\n    if (events === void 0) { events = ALL_EVENTS; }\r\n    changes.forEach(function (change) {\r\n        // skip unwanted change types\r\n        if (events.indexOf(change.type) > -1) {\r\n            current = processIndividualChange(current, change);\r\n        }\r\n    });\r\n    return current;\r\n}\r\n/**\r\n * Create an operator that allows you to compare the current emission with\r\n * the prior, even on first emission (where prior is undefined).\r\n */\r\nvar windowwise = function () {\r\n    return pipe(startWith(undefined), pairwise());\r\n};\r\n/**\r\n * Given two snapshots does their metadata match?\r\n * @param a\r\n * @param b\r\n */\r\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\r\n/**\r\n * Create an operator that filters out empty changes. We provide the\r\n * ability to filter on events, which means all changes can be filtered out.\r\n * This creates an empty array and would be incorrect to emit.\r\n */\r\nvar filterEmptyUnlessFirst = function () {\r\n    return pipe(windowwise(), filter(function (_a) {\r\n        var prior = _a[0], current = _a[1];\r\n        return current.length > 0 || prior === undefined;\r\n    }), map(function (_a) {\r\n        var current = _a[1];\r\n        return current;\r\n    }));\r\n};\r\n/**\r\n * Return a stream of document changes on a query. These results are not in sort order but in\r\n * order of occurence.\r\n * @param query\r\n */\r\nfunction collectionChanges(query, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return fromRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\r\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\r\n        var docChanges = currentSnapshot.docChanges();\r\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\r\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\r\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\r\n            // since either this docChanges() emission or the prior snapshot\r\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\r\n                var currentDocChange = docChanges.find(function (c) {\r\n                    return refEqual(c.doc.ref, currentDocSnapshot.ref);\r\n                });\r\n                if (currentDocChange) {\r\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\r\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\r\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\r\n                        return refEqual(d.ref, currentDocSnapshot.ref);\r\n                    });\r\n                    if (priorDocSnapshot &&\r\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\r\n                        return;\r\n                    }\r\n                }\r\n                docChanges.push({\r\n                    oldIndex: currentIndex,\r\n                    newIndex: currentIndex,\r\n                    type: 'modified',\r\n                    doc: currentDocSnapshot,\r\n                });\r\n            });\r\n        }\r\n        return docChanges;\r\n    }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\r\n}\r\n/**\r\n * Return a stream of document snapshots on a query. These results are in sort order.\r\n * @param query\r\n */\r\nfunction collection(query) {\r\n    return fromRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\r\n}\r\n/**\r\n * Return a stream of document changes on a query. These results are in sort order.\r\n * @param query\r\n */\r\nfunction sortedChanges(query, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return collectionChanges(query, options).pipe(scan(function (current, changes) {\r\n        return processDocumentChanges(current, changes, options.events);\r\n    }, []), distinctUntilChanged());\r\n}\r\n/**\r\n * Create a stream of changes as they occur it time. This method is similar\r\n * to docChanges() but it collects each event in an array over time.\r\n */\r\nfunction auditTrail(query, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return collectionChanges(query, options).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current, true), action, true); }, []));\r\n}\r\n/**\r\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\r\n * @param query\r\n * @param options\r\n */\r\nfunction collectionData(query, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return collection(query).pipe(map(function (arr) {\r\n        return arr.map(function (snap) { return snapToData(snap, options); });\r\n    }));\r\n}\r\nfunction collectionCountSnap(query) {\r\n    return from(getCountFromServer(query));\r\n}\r\nfunction collectionCount(query) {\r\n    return collectionCountSnap(query).pipe(map(function (snap) { return snap.data().count; }));\r\n}\r\n\r\nexport { auditTrail, collection, collectionChanges, collectionCount, collectionCountSnap, collectionData, doc, docData, fromRef, snapToData, sortedChanges };\r\n\r\n", "import { ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, VERSION, ɵAngularFireSchedulers, ɵAppCheckInstances, ɵzoneWrap } from '@angular/fire';\nimport { from, timer } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, NgModule, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { AuthInstances } from '@angular/fire/auth';\nimport { registerVersion } from 'firebase/app';\nimport { collectionChanges as collectionChanges$1, collection as collection$1, sortedChanges as sortedChanges$1, auditTrail as auditTrail$1, collectionData as collectionData$1, collectionCountSnap as collectionCountSnap$1, collectionCount as collectionCount$1, doc as doc$1, docData as docData$1, snapToData as snapToData$1, fromRef as fromRef$1 } from 'rxfire/firestore';\nimport { addDoc as addDoc$1, aggregateFieldEqual as aggregateFieldEqual$1, aggregateQuerySnapshotEqual as aggregateQuerySnapshotEqual$1, and as and$1, arrayRemove as arrayRemove$1, arrayUnion as arrayUnion$1, average as average$1, clearIndexedDbPersistence as clearIndexedDbPersistence$1, collection as collection$2, collectionGroup as collectionGroup$1, connectFirestoreEmulator as connectFirestoreEmulator$1, count as count$1, deleteAllPersistentCacheIndexes as deleteAllPersistentCacheIndexes$1, deleteDoc as deleteDoc$1, deleteField as deleteField$1, disableNetwork as disableNetwork$1, disablePersistentCacheIndexAutoCreation as disablePersistentCacheIndexAutoCreation$1, doc as doc$2, documentId as documentId$1, enableIndexedDbPersistence as enableIndexedDbPersistence$1, enableMultiTabIndexedDbPersistence as enableMultiTabIndexedDbPersistence$1, enableNetwork as enableNetwork$1, enablePersistentCacheIndexAutoCreation as enablePersistentCacheIndexAutoCreation$1, endAt as endAt$1, endBefore as endBefore$1, getAggregateFromServer as getAggregateFromServer$1, getCountFromServer as getCountFromServer$1, getDoc as getDoc$1, getDocFromCache as getDocFromCache$1, getDocFromServer as getDocFromServer$1, getDocs as getDocs$1, getDocsFromCache as getDocsFromCache$1, getDocsFromServer as getDocsFromServer$1, getFirestore as getFirestore$1, getPersistentCacheIndexManager as getPersistentCacheIndexManager$1, increment as increment$1, initializeFirestore as initializeFirestore$1, limit as limit$1, limitToLast as limitToLast$1, loadBundle as loadBundle$1, memoryEagerGarbageCollector as memoryEagerGarbageCollector$1, memoryLocalCache as memoryLocalCache$1, memoryLruGarbageCollector as memoryLruGarbageCollector$1, namedQuery as namedQuery$1, onSnapshot as onSnapshot$1, onSnapshotsInSync as onSnapshotsInSync$1, or as or$1, orderBy as orderBy$1, persistentLocalCache as persistentLocalCache$1, persistentMultipleTabManager as persistentMultipleTabManager$1, persistentSingleTabManager as persistentSingleTabManager$1, query as query$1, queryEqual as queryEqual$1, refEqual as refEqual$1, runTransaction as runTransaction$1, serverTimestamp as serverTimestamp$1, setDoc as setDoc$1, setIndexConfiguration as setIndexConfiguration$1, setLogLevel as setLogLevel$1, snapshotEqual as snapshotEqual$1, startAfter as startAfter$1, startAt as startAt$1, sum as sum$1, terminate as terminate$1, updateDoc as updateDoc$1, waitForPendingWrites as waitForPendingWrites$1, where as where$1, writeBatch as writeBatch$1 } from 'firebase/firestore';\nexport * from 'firebase/firestore';\nclass Firestore {\n  constructor(firestore) {\n    return firestore;\n  }\n}\nconst FIRESTORE_PROVIDER_NAME = 'firestore';\nclass FirestoreInstances {\n  constructor() {\n    return ɵgetAllInstancesOf(FIRESTORE_PROVIDER_NAME);\n  }\n}\nconst firestoreInstance$ = timer(0, 300).pipe(concatMap(() => from(ɵgetAllInstancesOf(FIRESTORE_PROVIDER_NAME))), distinct());\nconst PROVIDED_FIRESTORE_INSTANCES = new InjectionToken('angularfire2.firestore-instances');\nfunction defaultFirestoreInstanceFactory(provided, defaultApp) {\n  const defaultFirestore = ɵgetDefaultInstanceOf(FIRESTORE_PROVIDER_NAME, provided, defaultApp);\n  return defaultFirestore && new Firestore(defaultFirestore);\n}\nfunction firestoreInstanceFactory(fn) {\n  return (zone, injector) => {\n    const firestore = zone.runOutsideAngular(() => fn(injector));\n    return new Firestore(firestore);\n  };\n}\nconst FIRESTORE_INSTANCES_PROVIDER = {\n  provide: FirestoreInstances,\n  deps: [[new Optional(), PROVIDED_FIRESTORE_INSTANCES]]\n};\nconst DEFAULT_FIRESTORE_INSTANCE_PROVIDER = {\n  provide: Firestore,\n  useFactory: defaultFirestoreInstanceFactory,\n  deps: [[new Optional(), PROVIDED_FIRESTORE_INSTANCES], FirebaseApp]\n};\nclass FirestoreModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'fst');\n  }\n  static ɵfac = function FirestoreModule_Factory(t) {\n    return new (t || FirestoreModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FirestoreModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_FIRESTORE_INSTANCE_PROVIDER, FIRESTORE_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FirestoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_FIRESTORE_INSTANCE_PROVIDER, FIRESTORE_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction provideFirestore(fn, ...deps) {\n  return {\n    ngModule: FirestoreModule,\n    providers: [{\n      provide: PROVIDED_FIRESTORE_INSTANCES,\n      useFactory: firestoreInstanceFactory(fn),\n      multi: true,\n      deps: [NgZone, Injector, ɵAngularFireSchedulers, FirebaseApps,\n      // Firestore+Auth work better if Auth is loaded first\n      [new Optional(), AuthInstances], [new Optional(), ɵAppCheckInstances], ...deps]\n    }]\n  };\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst collectionChanges = ɵzoneWrap(collectionChanges$1, true);\nconst collectionSnapshots = ɵzoneWrap(collection$1, true);\nconst sortedChanges = ɵzoneWrap(sortedChanges$1, true);\nconst auditTrail = ɵzoneWrap(auditTrail$1, true);\nconst collectionData = ɵzoneWrap(collectionData$1, true);\nconst collectionCountSnap = ɵzoneWrap(collectionCountSnap$1, true);\nconst collectionCount = ɵzoneWrap(collectionCount$1, true);\nconst docSnapshots = ɵzoneWrap(doc$1, true);\nconst docData = ɵzoneWrap(docData$1, true);\nconst snapToData = ɵzoneWrap(snapToData$1, true);\nconst fromRef = ɵzoneWrap(fromRef$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst addDoc = ɵzoneWrap(addDoc$1, true);\nconst aggregateFieldEqual = ɵzoneWrap(aggregateFieldEqual$1, true);\nconst aggregateQuerySnapshotEqual = ɵzoneWrap(aggregateQuerySnapshotEqual$1, true);\nconst and = ɵzoneWrap(and$1, true);\nconst arrayRemove = ɵzoneWrap(arrayRemove$1, true);\nconst arrayUnion = ɵzoneWrap(arrayUnion$1, true);\nconst average = ɵzoneWrap(average$1, true);\nconst clearIndexedDbPersistence = ɵzoneWrap(clearIndexedDbPersistence$1, true);\nconst collection = ɵzoneWrap(collection$2, true);\nconst collectionGroup = ɵzoneWrap(collectionGroup$1, true);\nconst connectFirestoreEmulator = ɵzoneWrap(connectFirestoreEmulator$1, true);\nconst count = ɵzoneWrap(count$1, true);\nconst deleteAllPersistentCacheIndexes = ɵzoneWrap(deleteAllPersistentCacheIndexes$1, true);\nconst deleteDoc = ɵzoneWrap(deleteDoc$1, true);\nconst deleteField = ɵzoneWrap(deleteField$1, true);\nconst disableNetwork = ɵzoneWrap(disableNetwork$1, true);\nconst disablePersistentCacheIndexAutoCreation = ɵzoneWrap(disablePersistentCacheIndexAutoCreation$1, true);\nconst doc = ɵzoneWrap(doc$2, true);\nconst documentId = ɵzoneWrap(documentId$1, true);\nconst enableIndexedDbPersistence = ɵzoneWrap(enableIndexedDbPersistence$1, true);\nconst enableMultiTabIndexedDbPersistence = ɵzoneWrap(enableMultiTabIndexedDbPersistence$1, true);\nconst enableNetwork = ɵzoneWrap(enableNetwork$1, true);\nconst enablePersistentCacheIndexAutoCreation = ɵzoneWrap(enablePersistentCacheIndexAutoCreation$1, true);\nconst endAt = ɵzoneWrap(endAt$1, true);\nconst endBefore = ɵzoneWrap(endBefore$1, true);\nconst getAggregateFromServer = ɵzoneWrap(getAggregateFromServer$1, true);\nconst getCountFromServer = ɵzoneWrap(getCountFromServer$1, true);\nconst getDoc = ɵzoneWrap(getDoc$1, true);\nconst getDocFromCache = ɵzoneWrap(getDocFromCache$1, true);\nconst getDocFromServer = ɵzoneWrap(getDocFromServer$1, true);\nconst getDocs = ɵzoneWrap(getDocs$1, true);\nconst getDocsFromCache = ɵzoneWrap(getDocsFromCache$1, true);\nconst getDocsFromServer = ɵzoneWrap(getDocsFromServer$1, true);\nconst getFirestore = ɵzoneWrap(getFirestore$1, true);\nconst getPersistentCacheIndexManager = ɵzoneWrap(getPersistentCacheIndexManager$1, true);\nconst increment = ɵzoneWrap(increment$1, true);\nconst initializeFirestore = ɵzoneWrap(initializeFirestore$1, true);\nconst limit = ɵzoneWrap(limit$1, true);\nconst limitToLast = ɵzoneWrap(limitToLast$1, true);\nconst loadBundle = ɵzoneWrap(loadBundle$1, true);\nconst memoryEagerGarbageCollector = ɵzoneWrap(memoryEagerGarbageCollector$1, true);\nconst memoryLocalCache = ɵzoneWrap(memoryLocalCache$1, true);\nconst memoryLruGarbageCollector = ɵzoneWrap(memoryLruGarbageCollector$1, true);\nconst namedQuery = ɵzoneWrap(namedQuery$1, true);\nconst onSnapshot = ɵzoneWrap(onSnapshot$1, true);\nconst onSnapshotsInSync = ɵzoneWrap(onSnapshotsInSync$1, true);\nconst or = ɵzoneWrap(or$1, true);\nconst orderBy = ɵzoneWrap(orderBy$1, true);\nconst persistentLocalCache = ɵzoneWrap(persistentLocalCache$1, true);\nconst persistentMultipleTabManager = ɵzoneWrap(persistentMultipleTabManager$1, true);\nconst persistentSingleTabManager = ɵzoneWrap(persistentSingleTabManager$1, true);\nconst query = ɵzoneWrap(query$1, true);\nconst queryEqual = ɵzoneWrap(queryEqual$1, true);\nconst refEqual = ɵzoneWrap(refEqual$1, true);\nconst runTransaction = ɵzoneWrap(runTransaction$1, true);\nconst serverTimestamp = ɵzoneWrap(serverTimestamp$1, true);\nconst setDoc = ɵzoneWrap(setDoc$1, true);\nconst setIndexConfiguration = ɵzoneWrap(setIndexConfiguration$1, true);\nconst setLogLevel = ɵzoneWrap(setLogLevel$1, true);\nconst snapshotEqual = ɵzoneWrap(snapshotEqual$1, true);\nconst startAfter = ɵzoneWrap(startAfter$1, true);\nconst startAt = ɵzoneWrap(startAt$1, true);\nconst sum = ɵzoneWrap(sum$1, true);\nconst terminate = ɵzoneWrap(terminate$1, true);\nconst updateDoc = ɵzoneWrap(updateDoc$1, true);\nconst waitForPendingWrites = ɵzoneWrap(waitForPendingWrites$1, true);\nconst where = ɵzoneWrap(where$1, true);\nconst writeBatch = ɵzoneWrap(writeBatch$1, true);\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { Firestore, FirestoreInstances, FirestoreModule, addDoc, aggregateFieldEqual, aggregateQuerySnapshotEqual, and, arrayRemove, arrayUnion, auditTrail, average, clearIndexedDbPersistence, collection, collectionChanges, collectionCount, collectionCountSnap, collectionData, collectionGroup, collectionSnapshots, connectFirestoreEmulator, count, deleteAllPersistentCacheIndexes, deleteDoc, deleteField, disableNetwork, disablePersistentCacheIndexAutoCreation, doc, docData, docSnapshots, documentId, enableIndexedDbPersistence, enableMultiTabIndexedDbPersistence, enableNetwork, enablePersistentCacheIndexAutoCreation, endAt, endBefore, firestoreInstance$, fromRef, getAggregateFromServer, getCountFromServer, getDoc, getDocFromCache, getDocFromServer, getDocs, getDocsFromCache, getDocsFromServer, getFirestore, getPersistentCacheIndexManager, increment, initializeFirestore, limit, limitToLast, loadBundle, memoryEagerGarbageCollector, memoryLocalCache, memoryLruGarbageCollector, namedQuery, onSnapshot, onSnapshotsInSync, or, orderBy, persistentLocalCache, persistentMultipleTabManager, persistentSingleTabManager, provideFirestore, query, queryEqual, refEqual, runTransaction, serverTimestamp, setDoc, setIndexConfiguration, setLogLevel, snapToData, snapshotEqual, sortedChanges, startAfter, startAt, sum, terminate, updateDoc, waitForPendingWrites, where, writeBatch };\n"],
  "mappings": "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",
  "names": ["__assign", "from", "doc", "query", "collection", "collectionChanges", "collection", "sortedChanges", "auditTrail", "collectionData", "collectionCountSnap", "collectionCount", "doc", "docData", "snapToData", "fromRef", "addDoc", "aggregateFieldEqual", "aggregateQuerySnapshotEqual", "and", "arrayRemove", "arrayUnion", "average", "clearIndexedDbPersistence", "collectionGroup", "connectFirestoreEmulator", "count", "deleteAllPersistentCacheIndexes", "deleteDoc", "deleteField", "disableNetwork", "disablePersistentCacheIndexAutoCreation", "documentId", "enableIndexedDbPersistence", "enableMultiTabIndexedDbPersistence", "enableNetwork", "enablePersistentCacheIndexAutoCreation", "endAt", "endBefore", "getAggregateFromServer", "getCountFromServer", "getDoc", "getDocFromCache", "getDocFromServer", "getDocs", "getDocsFromCache", "getDocsFromServer", "getFirestore", "getPersistentCacheIndexManager", "increment", "initializeFirestore", "limit", "limitToLast", "loadBundle", "memoryEagerGarbageCollector", "memoryLocalCache", "memoryLruGarbageCollector", "namedQuery", "onSnapshot", "onSnapshotsInSync", "or", "orderBy", "persistentLocalCache", "persistentMultipleTabManager", "persistentSingleTabManager", "query", "queryEqual", "refEqual", "runTransaction", "serverTimestamp", "setDoc", "setIndexConfiguration", "setLogLevel", "snapshotEqual", "startAfter", "startAt", "sum", "terminate", "updateDoc", "waitForPendingWrites", "where", "writeBatch"]
}
